<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>GISignalInfo (ocaml-gobject-introspection.GObjectIntrospection.GISignalInfo)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">ocaml-gobject-introspection</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">GObjectIntrospection.GISignalInfo</span></h1></header><p>GISignalInfo â€” Struct representing a signal.</p><div class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>t</code><code></code><code></code></div><div class="doc"><p>GISignalInfo represents a signal. It's a sub-struct of GICallableInfo and
contains a set of flags and a class closure.
See GICallableInfo for information on how to retreive arguments and other
metadata from the signal.</p></div></div><div class="spec val" id="val-signalinfo"><a href="#val-signalinfo" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>signalinfo : <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.typ</code></div><div class="doc"></div></div><div class="spec val" id="val-true_stops_emit"><a href="#val-true_stops_emit" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>true_stops_emit : <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p>Obtain if the returning true in the signal handler will stop the emission
of the signal.</p></div></div><div class="spec type" id="type-flags"><a href="#type-flags" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>flags</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-flags.Run_first" class="anchored"><td class="def constructor"><a href="#type-flags.Run_first" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Run_first</span></code></td><td class="doc"><p>(** Invoke the object method handler in the first
emission stage. *)</p></td></tr><tr id="type-flags.Run_last" class="anchored"><td class="def constructor"><a href="#type-flags.Run_last" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Run_last</span></code></td><td class="doc"><p>(** Invoke the object method handler in the third
emission stage. *)</p></td></tr><tr id="type-flags.Run_cleanup" class="anchored"><td class="def constructor"><a href="#type-flags.Run_cleanup" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Run_cleanup</span></code></td><td class="doc"><p>(** Invoke the object method handler in the last
emission stage. *)</p></td></tr><tr id="type-flags.No_recurse" class="anchored"><td class="def constructor"><a href="#type-flags.No_recurse" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">No_recurse</span></code></td><td class="doc"><p>(** Signals being emitted for an object while currently
being in emission for this very object will not be
emitted recursively, but instead cause the first
emission to be restarted. *)</p></td></tr><tr id="type-flags.Detailed" class="anchored"><td class="def constructor"><a href="#type-flags.Detailed" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Detailed</span></code></td><td class="doc"><p>(** This signal supports &quot;::detail&quot; appendices to the
signal name upon handler connections and emissions. *)</p></td></tr><tr id="type-flags.Action" class="anchored"><td class="def constructor"><a href="#type-flags.Action" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Action</span></code></td><td class="doc"><p>(** Action signals are signals that may freely be
emitted on alive objects from user code via
g_signal_emit() and friends, without the need of
being embedded into extra code that performs pre or
post emission adjustments on the object. They can
also be thought of as object methods which can be
called generically by third-party code. *)</p></td></tr><tr id="type-flags.No_hooks" class="anchored"><td class="def constructor"><a href="#type-flags.No_hooks" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">No_hooks</span></code></td><td class="doc"><p>(** No emissions hooks are supported for this signal. *)</p></td></tr><tr id="type-flags.Must_collect" class="anchored"><td class="def constructor"><a href="#type-flags.Must_collect" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Must_collect</span></code></td><td class="doc"><p>(** Varargs signal emission will always collect the
arguments, even if there are no signal handlers
connected. Since 2.30. *)</p></td></tr><tr id="type-flags.Deprecated" class="anchored"><td class="def constructor"><a href="#type-flags.Deprecated" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">Deprecated</span></code></td><td class="doc"><p>(** The signal is deprecated and will be removed in a
future version. A warning will be generated if it is
connected while running with G_ENABLE_DIAGNOSTIC=1.
Since 2.32. *)</p></td></tr></table><code></code></div><div class="doc"><p>The signal flags are used to specify a signal's behaviour, the overall
signal description outlines how especially the RUN flags control the stages
of a signal emission.</p></div></div><div class="spec val" id="val-get_flags"><a href="#val-get_flags" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_flags : <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-flags">flags</a> list</code></div><div class="doc"><p>Obtain the flags for this signal info. See GSignalFlags for more
information about possible flag values.</p></div></div><div class="spec val" id="val-get_class_closure"><a href="#val-get_class_closure" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>get_class_closure : <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="../GICallableInfo/index.html#type-t">GICallableInfo.t</a> Ctypes.structure Ctypes.ptr option</code></div><div class="doc"><p>Obtain the class closure for this signal if one is set. The class closure
is a virtual function on the type that the signal belongs to. If the signal
lacks a closure None will be returned.
In order to avoid circular call graph between GISignalInfo and GIVFuncInfo,
this function will return a GICallableInfo. It is upto the user to use
GIVSignalInfo.from_callableinfo in order to have the GIVFuncInfo.</p></div></div><div class="spec val" id="val-cast_from_baseinfo"><a href="#val-cast_from_baseinfo" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cast_from_baseinfo : <a href="../GIBaseInfo/index.html#type-t">GIBaseInfo.t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr</code></div><div class="doc"><p>Just cast OCaml Ctypes base info to signal info.</p></div></div><div class="spec val" id="val-cast_to_baseinfo"><a href="#val-cast_to_baseinfo" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cast_to_baseinfo : <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="../GIBaseInfo/index.html#type-t">GIBaseInfo.t</a> Ctypes.structure Ctypes.ptr</code></div><div class="doc"><p>Just cast OCaml Ctypes signal info to base info</p></div></div><div class="spec val" id="val-add_unref_finaliser"><a href="#val-add_unref_finaliser" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>add_unref_finaliser : <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr</code></div><div class="doc"><p>Add unref of the C underlying structure whith Gc.finalise.</p></div></div><div class="spec val" id="val-from_baseinfo"><a href="#val-from_baseinfo" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>from_baseinfo : <a href="../GIBaseInfo/index.html#type-t">GIBaseInfo.t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr</code></div><div class="doc"><p>Return a GISignalInfo.t from a GIBaseInfo.t, the underlying C structure
ref count is increased and the value is Gc.finalis&quot;ed&quot; with
GIBaseInfo.baseinfo_unref.</p></div></div><div class="spec val" id="val-to_baseinfo"><a href="#val-to_baseinfo" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>to_baseinfo : <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="../GIBaseInfo/index.html#type-t">GIBaseInfo.t</a> Ctypes.structure Ctypes.ptr</code></div><div class="doc"><p>Return a GIBaseInfo.t from a GISignalInfo, the underlying C structure
ref count is increased and the value is Gc.finalis&quot;ed&quot; with
GIBaseInfo.baseinfo_unref.</p></div></div><div class="spec val" id="val-cast_from_callableinfo"><a href="#val-cast_from_callableinfo" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cast_from_callableinfo : <a href="../GICallableInfo/index.html#type-t">GICallableInfo.t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr</code></div><div class="doc"><p>Just cast OCaml Ctypes callable info to signal info.</p></div></div><div class="spec val" id="val-cast_to_callableinfo"><a href="#val-cast_to_callableinfo" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cast_to_callableinfo : <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="../GICallableInfo/index.html#type-t">GICallableInfo.t</a> Ctypes.structure Ctypes.ptr</code></div><div class="doc"><p>Just cast OCaml Ctypes signal info to callable info</p></div></div><div class="spec val" id="val-from_callableinfo"><a href="#val-from_callableinfo" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>from_callableinfo : <a href="../GICallableInfo/index.html#type-t">GICallableInfo.t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr</code></div><div class="doc"><p>Return a GISignalInfo.t from a GICallableInfo.t, the underlying C structure
ref count is increased and the value is Gc.finalis&quot;ed&quot; with
GIBaseInfo.baseinfo_unref.</p></div></div><div class="spec val" id="val-to_callableinfo"><a href="#val-to_callableinfo" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>to_callableinfo : <a href="index.html#type-t">t</a> Ctypes.structure Ctypes.ptr <span class="keyword">&#8209;&gt;</span> <a href="../GICallableInfo/index.html#type-t">GICallableInfo.t</a> Ctypes.structure Ctypes.ptr</code></div><div class="doc"><p>Return a GICallableInfo.t from a GISignalInfo, the underlying C structure
ref count is increased and the value is Gc.finalis&quot;ed&quot; with
GIBaseInfo.baseinfo_unref.</p></div></div></body></html>